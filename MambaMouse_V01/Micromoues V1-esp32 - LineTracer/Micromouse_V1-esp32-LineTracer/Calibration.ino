//Calibration

static const unsigned char PROGMEM calibrating[] =
{ //Calibrating Logo
  0x00, 0x00, 0x00, 0x01, 0xc1, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x01, 0xfc, 0x00, 0x01, 0xc3, 0xc7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x07, 0xfc, 0x00, 0x01, 0xc3, 0xc7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
  0x0f, 0xfc, 0x00, 0x01, 0xc3, 0xc7, 0x80, 0x00, 0x00, 0x00, 0x07, 0x83, 0x80, 0x00, 0x00, 0x00,
  0x1f, 0x84, 0x00, 0x01, 0xc0, 0x07, 0x80, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x00, 0x01, 0xc0, 0x07, 0x80, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x3c, 0x00, 0x1f, 0x81, 0xc3, 0xc7, 0xbe, 0x0f, 0x30, 0xfc, 0x1f, 0xe3, 0x87, 0x3e, 0x03, 0xef,
  0x7c, 0x00, 0x3f, 0xe1, 0xc3, 0xc7, 0xff, 0x8f, 0x79, 0xff, 0x1f, 0xe3, 0x87, 0x7f, 0x07, 0xff,
  0x78, 0x00, 0x3f, 0xe1, 0xc3, 0xc7, 0xff, 0x8f, 0xf9, 0xff, 0x1f, 0xe3, 0x87, 0xff, 0x0f, 0xff,
  0x78, 0x00, 0x00, 0xe1, 0xc3, 0xc7, 0xc7, 0x8f, 0xc0, 0x07, 0x87, 0x83, 0x87, 0x8f, 0x0f, 0x1f,
  0x78, 0x00, 0x00, 0xf1, 0xc3, 0xc7, 0x83, 0xcf, 0x80, 0x07, 0x87, 0x83, 0x87, 0x87, 0x9e, 0x0f,
  0x78, 0x00, 0x1f, 0xf1, 0xc3, 0xc7, 0x83, 0xcf, 0x00, 0xff, 0x87, 0x83, 0x87, 0x07, 0x9e, 0x0f,
  0x7c, 0x00, 0x7f, 0xf1, 0xc3, 0xc7, 0x83, 0xcf, 0x03, 0xff, 0x87, 0x83, 0x87, 0x07, 0x9e, 0x0f,
  0x7c, 0x00, 0x78, 0xf1, 0xc3, 0xc7, 0x83, 0xcf, 0x03, 0xc7, 0x87, 0x83, 0x87, 0x07, 0x9e, 0x0f,
  0x3e, 0x00, 0xf0, 0xf1, 0xc3, 0xc7, 0x87, 0xcf, 0x07, 0x87, 0x87, 0x83, 0x87, 0x07, 0x9e, 0x0f,
  0x3f, 0x8c, 0xf1, 0xf1, 0xc3, 0xc7, 0xc7, 0x8f, 0x07, 0x8f, 0x87, 0x83, 0x87, 0x07, 0x9f, 0x1f,
  0x1f, 0xfc, 0x7f, 0xf1, 0xc3, 0xc7, 0xff, 0x8f, 0x03, 0xff, 0x87, 0xe3, 0x87, 0x07, 0x8f, 0xff,
  0x0f, 0xfc, 0x7f, 0xf1, 0xc3, 0xc7, 0xff, 0x0f, 0x03, 0xff, 0x87, 0xe3, 0x87, 0x07, 0x87, 0xff,
  0x03, 0xf8, 0x3c, 0xe1, 0xc3, 0x87, 0xbe, 0x07, 0x01, 0xe7, 0x83, 0xe3, 0x87, 0x07, 0x03, 0xcf,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x7e,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

boolean Update = false;
unsigned long calibrationTime = 0;

int analogMaxvalue = 4095;
int pixelWidth = 25;

void calibration()
{
  // int sensors = 0;
  // for (int i = 0; i < sizeof(IRRecPin); i++)
  // {
  //   sensors++;
  // }
  
  // do {} while (digitalRead(bStart) == 1);//wait until button is realeased
  // // digitalWrite(buzzer, LOW);
  // digitalWrite(led, LOW);

  //////////////////////////////////////////////////////////////////////////////////////////
  calibrationTime = millis();
  do
  {
    //    motor(20, 20);
    int value = 0;

    OLED.clearDisplay();
    for (int i = 0; i < sizeof(IRRecPin); i++)
    {
      value = analogRead(IRRecPin[i]);
      OLED.drawRect(i * pixelWidth, 32, pixelWidth, 32, SSD1306_WHITE);
      OLED.fillRect(i * pixelWidth, 64 - map(value, 0, analogMaxvalue, 0, 32), pixelWidth, map(value, 0, analogMaxvalue, 0, 32), SSD1306_WHITE);

      if (minIR[i] > value) {
        minIR[i] = value;
      }
      else if (maxIR[i] < value)
      {
        maxIR[i] = value;
      }
      midIR[i] = ( minIR[i] + maxIR[i] ) * 0.5;

      Serial.print("  ");
      Serial.print(i);
      Serial.print(" = ");
      Serial.print(midIR[i]);
      Serial.print("  ");

    }
    Serial.println("  ");
    OLED.drawBitmap(  (OLED.width()  - 128 ) / 2, (OLED.height() - 64) / 2, calibrating, 128, 25, 1);
    OLED.display();
    Update = true;
  } while ((millis() - calibrationTime) < 5000);

  //////////////////////////////////////////////////////////////////////////////////////////

  calibrationTime = millis();
  do
  {
    //    motor(-20, -20);
    int value = 0;

    OLED.clearDisplay();
    for (int i = 0; i < sizeof(IRRecPin); i++)
    {
      value = analogRead(IRRecPin[i]);
      OLED.drawRect(i * pixelWidth, 32, pixelWidth, 32, SSD1306_WHITE);
      OLED.fillRect(i * pixelWidth, 64 - map(value, 0, analogMaxvalue, 0, 32), pixelWidth, map(value, 0, analogMaxvalue, 0, 32), SSD1306_WHITE);

      if (minIR[i] > value) {
        minIR[i] = value;
      }
      else if (maxIR[i] < value)
      {
        maxIR[i] = value;
      }
      midIR[i] = ( minIR[i] + maxIR[i] ) * 0.5;

      Serial.print("  ");
      Serial.print(i);
      Serial.print(" = ");
      Serial.print(midIR[i]);
      Serial.print("  ");

    }
    Serial.println("  ");
    OLED.display();
    Update = true;

  } while ((millis() - calibrationTime) < 5000);

  //////////////////////////////////////////////////////////////////////////////////////////
  OLED.clearDisplay();
  for (int i = 0; i < sizeof(IRRecPin); i++)
  {
    OLED.setTextSize(2);
    OLED.setTextColor(SSD1306_WHITE);
    OLED.setCursor(0, 0);
    OLED.cp437(true);
    OLED.print("Calibrated");

    OLED.drawRect(i * pixelWidth, 32, pixelWidth, 32, SSD1306_WHITE);
    OLED.fillRect(i * pixelWidth, 64 - map(midIR[i], 0, analogMaxvalue, 0, 32), pixelWidth, map(midIR[i], 0, analogMaxvalue, 0, 32), SSD1306_WHITE);
  }

  OLED.display(); //update the display

  //////////////////////////////////////////////////////////////////////////////////////////
  //  motor(0, 0);
  // Update=true;
  // updateEEPROM();
  // do {
  //   IR_Recv();
  // } while ((digitalRead(bStart) == 0) && (irRecvResults.value != 0xFF38C7)); //wait until button is pressed
  // do {
  //   IR_Recv();
  // } while ((digitalRead(bStart) == 1) || (irRecvResults.value == 0xFF38C7)); //ensure button is released
  store_memory();
  delay(3000);
  Start = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// void updateEEPROM()
// {
//   if (Update == true)
//   {
//     for (int i = 0; i < sizeof(IR); i++)
//     {
//       EEPROM.update(i, (midIR[i] / 4));
//       Serial.print( midIR[i], DEC);
//       Serial.print(" ");
//     }
//     Update = false;
//     Serial.println( );
//   }
//   else
//   {
//   }
// }

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// void readEEPROM() {
//   for (int i = 0; i < sizeof(IR); i++)
//   {
//     midIR[i] = EEPROM.read(i) * 4;
//     Serial.print( i);
//     Serial.print(" = ");
//     Serial.print( (midIR[i] ), DEC);
//     Serial.print("  ");
//   }
//   Serial.println( );
// }

////////////////////////////////////////////////////////////////////////////////////////////////
//  
// save calibration values into esp32
#include <Preferences.h>
Preferences preferences;

unsigned int IR1 = 0;
unsigned int IR2 = 0;
unsigned int IR3 = 0;
unsigned int IR4 = 0;
unsigned int IR5 = 0;

void read_memory() {
  preferences.begin("lineData", false);

  // retrieve saved data
  midIR[0] = preferences.getUInt("IR1", 0);
  midIR[1] = preferences.getUInt("IR2", 0);
  midIR[2] = preferences.getUInt("IR3", 0);
  midIR[3] = preferences.getUInt("IR4", 0);
  midIR[4] = preferences.getUInt("IR5", 0);

}

void store_memory()
{
  preferences.putUInt("IR1", midIR[0]);
  preferences.putUInt("IR2", midIR[1]);
  preferences.putUInt("IR3", midIR[2]);
  preferences.putUInt("IR4", midIR[3]);
  preferences.putUInt("IR5", midIR[4]);
  preferences.end();
}





